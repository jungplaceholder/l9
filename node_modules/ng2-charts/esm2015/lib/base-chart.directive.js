/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Directive, Input, Output, EventEmitter, ElementRef, } from '@angular/core';
import * as chartJs from 'chart.js';
import { getColors } from './get-colors';
import { ThemeService } from './theme.service';
import * as _ from 'lodash';
/**
 * @record
 */
export function PluginServiceGlobalRegistration() { }
if (false) {
    /** @type {?|undefined} */
    PluginServiceGlobalRegistration.prototype.id;
}
/**
 * @record
 */
export function PluginServiceRegistrationOptions() { }
if (false) {
    /**
     * @param {?} chartInstance
     * @param {?=} options
     * @return {?}
     */
    PluginServiceRegistrationOptions.prototype.beforeInit = function (chartInstance, options) { };
    /**
     * @param {?} chartInstance
     * @param {?=} options
     * @return {?}
     */
    PluginServiceRegistrationOptions.prototype.afterInit = function (chartInstance, options) { };
    /**
     * @param {?} chartInstance
     * @param {?=} options
     * @return {?}
     */
    PluginServiceRegistrationOptions.prototype.beforeUpdate = function (chartInstance, options) { };
    /**
     * @param {?} chartInstance
     * @param {?=} options
     * @return {?}
     */
    PluginServiceRegistrationOptions.prototype.afterUpdate = function (chartInstance, options) { };
    /**
     * @param {?} chartInstance
     * @param {?=} options
     * @return {?}
     */
    PluginServiceRegistrationOptions.prototype.beforeLayout = function (chartInstance, options) { };
    /**
     * @param {?} chartInstance
     * @param {?=} options
     * @return {?}
     */
    PluginServiceRegistrationOptions.prototype.afterLayout = function (chartInstance, options) { };
    /**
     * @param {?} chartInstance
     * @param {?=} options
     * @return {?}
     */
    PluginServiceRegistrationOptions.prototype.beforeDatasetsUpdate = function (chartInstance, options) { };
    /**
     * @param {?} chartInstance
     * @param {?=} options
     * @return {?}
     */
    PluginServiceRegistrationOptions.prototype.afterDatasetsUpdate = function (chartInstance, options) { };
    /**
     * @param {?} chartInstance
     * @param {?=} options
     * @return {?}
     */
    PluginServiceRegistrationOptions.prototype.beforeDatasetUpdate = function (chartInstance, options) { };
    /**
     * @param {?} chartInstance
     * @param {?=} options
     * @return {?}
     */
    PluginServiceRegistrationOptions.prototype.afterDatasetUpdate = function (chartInstance, options) { };
    /**
     * @param {?} chartInstance
     * @param {?=} options
     * @return {?}
     */
    PluginServiceRegistrationOptions.prototype.beforeRender = function (chartInstance, options) { };
    /**
     * @param {?} chartInstance
     * @param {?=} options
     * @return {?}
     */
    PluginServiceRegistrationOptions.prototype.afterRender = function (chartInstance, options) { };
    /**
     * @param {?} chartInstance
     * @param {?} easing
     * @param {?=} options
     * @return {?}
     */
    PluginServiceRegistrationOptions.prototype.beforeDraw = function (chartInstance, easing, options) { };
    /**
     * @param {?} chartInstance
     * @param {?} easing
     * @param {?=} options
     * @return {?}
     */
    PluginServiceRegistrationOptions.prototype.afterDraw = function (chartInstance, easing, options) { };
    /**
     * @param {?} chartInstance
     * @param {?} easing
     * @param {?=} options
     * @return {?}
     */
    PluginServiceRegistrationOptions.prototype.beforeDatasetsDraw = function (chartInstance, easing, options) { };
    /**
     * @param {?} chartInstance
     * @param {?} easing
     * @param {?=} options
     * @return {?}
     */
    PluginServiceRegistrationOptions.prototype.afterDatasetsDraw = function (chartInstance, easing, options) { };
    /**
     * @param {?} chartInstance
     * @param {?} easing
     * @param {?=} options
     * @return {?}
     */
    PluginServiceRegistrationOptions.prototype.beforeDatasetDraw = function (chartInstance, easing, options) { };
    /**
     * @param {?} chartInstance
     * @param {?} easing
     * @param {?=} options
     * @return {?}
     */
    PluginServiceRegistrationOptions.prototype.afterDatasetDraw = function (chartInstance, easing, options) { };
    /**
     * @param {?} chartInstance
     * @param {?=} tooltipData
     * @param {?=} options
     * @return {?}
     */
    PluginServiceRegistrationOptions.prototype.beforeTooltipDraw = function (chartInstance, tooltipData, options) { };
    /**
     * @param {?} chartInstance
     * @param {?=} tooltipData
     * @param {?=} options
     * @return {?}
     */
    PluginServiceRegistrationOptions.prototype.afterTooltipDraw = function (chartInstance, tooltipData, options) { };
    /**
     * @param {?} chartInstance
     * @param {?} event
     * @param {?=} options
     * @return {?}
     */
    PluginServiceRegistrationOptions.prototype.beforeEvent = function (chartInstance, event, options) { };
    /**
     * @param {?} chartInstance
     * @param {?} event
     * @param {?=} options
     * @return {?}
     */
    PluginServiceRegistrationOptions.prototype.afterEvent = function (chartInstance, event, options) { };
    /**
     * @param {?} chartInstance
     * @param {?} newChartSize
     * @param {?=} options
     * @return {?}
     */
    PluginServiceRegistrationOptions.prototype.resize = function (chartInstance, newChartSize, options) { };
    /**
     * @param {?} chartInstance
     * @return {?}
     */
    PluginServiceRegistrationOptions.prototype.destroy = function (chartInstance) { };
    /**
     * @deprecated since version 2.5.0. Use `afterLayout` instead.
     * @param {?} chartInstance
     * @param {?=} options
     * @return {?}
     */
    PluginServiceRegistrationOptions.prototype.afterScaleUpdate = function (chartInstance, options) { };
}
export class BaseChartDirective {
    /**
     * @param {?} element
     * @param {?} themeService
     */
    constructor(element, themeService) {
        this.element = element;
        this.themeService = themeService;
        this.options = {};
        this.chartClick = new EventEmitter();
        this.chartHover = new EventEmitter();
        this.initFlag = false;
        this.subs = [];
    }
    /**
     * Register a plugin.
     * @param {?} plugin
     * @return {?}
     */
    static registerPlugin(plugin) {
        chartJs.Chart.plugins.register(plugin);
    }
    /**
     * @param {?} plugin
     * @return {?}
     */
    static unregisterPlugin(plugin) {
        chartJs.Chart.plugins.unregister(plugin);
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.ctx = this.element.nativeElement.getContext('2d');
        this.initFlag = true;
        if (this.data || this.datasets) {
            this.refresh();
        }
        this.subs.push(this.themeService.colorschemesOptions.subscribe((/**
         * @param {?} r
         * @return {?}
         */
        r => this.themeChanged(r))));
    }
    /**
     * @private
     * @param {?} options
     * @return {?}
     */
    themeChanged(options) {
        this.refresh();
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (this.initFlag) {
            /** @type {?} */
            let updateRequired = false;
            // Check if the changes are in the data or datasets or labels or legend
            if (changes.hasOwnProperty('data') || changes.hasOwnProperty('datasets')) {
                if (changes.data) {
                    this.updateChartData(changes.data.currentValue);
                }
                else {
                    this.updateChartData(changes.datasets.currentValue);
                }
                updateRequired = true;
            }
            if (changes.hasOwnProperty('labels')) {
                this.chart.data.labels = changes.labels.currentValue;
                updateRequired = true;
            }
            if (changes.hasOwnProperty('legend')) {
                this.chart.config.options.legend.display = changes.legend.currentValue;
                this.chart.generateLegend();
                updateRequired = true;
            }
            if (updateRequired) {
                // ... if so, update chart
                this.chart.update();
            }
            else {
                // otherwise rebuild the chart
                this.refresh();
            }
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this.chart) {
            this.chart.destroy();
            this.chart = void 0;
        }
        this.subs.forEach((/**
         * @param {?} x
         * @return {?}
         */
        x => x.unsubscribe()));
    }
    /**
     * @param {?=} duration
     * @param {?=} lazy
     * @return {?}
     */
    update(duration, lazy) {
        return this.chart.update(duration, lazy);
    }
    /**
     * @param {?} index
     * @param {?} hidden
     * @return {?}
     */
    hideDataset(index, hidden) {
        this.chart.getDatasetMeta(index).hidden = hidden;
        this.chart.update();
    }
    /**
     * @param {?} index
     * @return {?}
     */
    isDatasetHidden(index) {
        return this.chart.getDatasetMeta(index).hidden;
    }
    /**
     * @return {?}
     */
    toBase64Image() {
        return this.chart.toBase64Image();
    }
    /**
     * @param {?} ctx
     * @return {?}
     */
    getChartBuilder(ctx /*, data:any[], options:any*/) {
        /** @type {?} */
        const datasets = this.getDatasets();
        /** @type {?} */
        const options = Object.assign({}, this.options);
        if (this.legend === false) {
            options.legend = { display: false };
        }
        // hook for onHover and onClick events
        options.hover = options.hover || {};
        if (!options.hover.onHover) {
            options.hover.onHover = (/**
             * @param {?} event
             * @param {?} active
             * @return {?}
             */
            (event, active) => {
                if (active && !active.length) {
                    return;
                }
                this.chartHover.emit({ event, active });
            });
        }
        if (!options.onClick) {
            options.onClick = (/**
             * @param {?=} event
             * @param {?=} active
             * @return {?}
             */
            (event, active) => {
                this.chartClick.emit({ event, active });
            });
        }
        /** @type {?} */
        const mergedOptions = this.smartMerge(options, this.themeService.getColorschemesOptions());
        /** @type {?} */
        const chartConfig = {
            type: this.chartType,
            data: {
                labels: this.labels,
                datasets
            },
            plugins: this.plugins,
            options: mergedOptions,
        };
        return new chartJs.Chart(ctx, chartConfig);
    }
    /**
     * @param {?} options
     * @param {?} overrides
     * @param {?=} level
     * @return {?}
     */
    smartMerge(options, overrides, level = 0) {
        if (level === 0) {
            options = _.cloneDeep(options);
        }
        /** @type {?} */
        const keysToUpdate = Object.keys(overrides);
        keysToUpdate.forEach((/**
         * @param {?} key
         * @return {?}
         */
        key => {
            if (Array.isArray(overrides[key])) {
                /** @type {?} */
                const arrayElements = options[key];
                if (arrayElements) {
                    arrayElements.forEach((/**
                     * @param {?} r
                     * @return {?}
                     */
                    r => {
                        this.smartMerge(r, overrides[key][0], level + 1);
                    }));
                }
            }
            else if (typeof (overrides[key]) === 'object') {
                if (!(key in options)) {
                    options[key] = {};
                }
                this.smartMerge(options[key], overrides[key], level + 1);
            }
            else {
                options[key] = overrides[key];
            }
        }));
        if (level === 0) {
            return options;
        }
    }
    /**
     * @private
     * @param {?} v
     * @return {?}
     */
    isChartDataSetsArray(v) {
        /** @type {?} */
        const elm = v[0];
        return (typeof (elm) === 'object') && 'data' in elm;
    }
    /**
     * @private
     * @param {?} label
     * @return {?}
     */
    isMultiLineLabel(label) {
        return Array.isArray(label);
    }
    /**
     * @private
     * @param {?} label
     * @return {?}
     */
    joinLabel(label) {
        if (!label) {
            return null;
        }
        if (this.isMultiLineLabel(label)) {
            return label.join(' ');
        }
        else {
            return label;
        }
    }
    /**
     * @private
     * @param {?} newDataValues
     * @return {?}
     */
    updateChartData(newDataValues) {
        if (this.isChartDataSetsArray(newDataValues)) {
            if (newDataValues.length === this.chart.data.datasets.length) {
                this.chart.data.datasets.forEach((/**
                 * @param {?} dataset
                 * @param {?} i
                 * @return {?}
                 */
                (dataset, i) => {
                    dataset.data = newDataValues[i].data;
                    if (newDataValues[i].label) {
                        dataset.label = newDataValues[i].label;
                    }
                }));
            }
            else {
                this.chart.data.datasets = [...newDataValues];
            }
        }
        else if (!this.isSingleDataSet(newDataValues)) {
            if (newDataValues.length === this.chart.data.datasets.length) {
                this.chart.data.datasets.forEach((/**
                 * @param {?} dataset
                 * @param {?} i
                 * @return {?}
                 */
                (dataset, i) => {
                    dataset.data = newDataValues[i];
                }));
            }
            else {
                this.chart.data.datasets = newDataValues.map((/**
                 * @param {?} data
                 * @param {?} index
                 * @return {?}
                 */
                (data, index) => {
                    return { data, label: this.joinLabel(this.labels[index]) || `Label ${index}` };
                }));
            }
        }
        else {
            this.chart.data.datasets[0].data = newDataValues;
        }
    }
    /**
     * @private
     * @param {?} data
     * @return {?}
     */
    isSingleDataSet(data) {
        return !Array.isArray(data[0]);
    }
    /**
     * @private
     * @return {?}
     */
    getDatasets() {
        /** @type {?} */
        let datasets = void 0;
        // in case if datasets is not provided, but data is present
        if (!this.datasets || !this.datasets.length && (this.data && this.data.length)) {
            if (!this.isSingleDataSet(this.data)) {
                datasets = this.data.map((/**
                 * @param {?} data
                 * @param {?} index
                 * @return {?}
                 */
                (data, index) => {
                    return { data, label: this.joinLabel(this.labels[index]) || `Label ${index}` };
                }));
            }
            else {
                datasets = [{ data: this.data, label: `Label 0` }];
            }
        }
        if (this.datasets && this.datasets.length ||
            (datasets && datasets.length)) {
            datasets = (this.datasets || datasets)
                .map((/**
             * @param {?} elm
             * @param {?} index
             * @return {?}
             */
            (elm, index) => {
                /** @type {?} */
                const newElm = Object.assign({}, elm);
                if (this.colors && this.colors.length) {
                    Object.assign(newElm, this.colors[index]);
                }
                else {
                    Object.assign(newElm, getColors(this.chartType, index, newElm.data.length));
                }
                return newElm;
            }));
        }
        if (!datasets) {
            throw new Error(`ng-charts configuration error,
      data or datasets field are required to render char ${this.chartType}`);
        }
        return datasets;
    }
    /**
     * @private
     * @return {?}
     */
    refresh() {
        // if (this.options && this.options.responsive) {
        //   setTimeout(() => this.refresh(), 50);
        // }
        // todo: remove this line, it is producing flickering
        if (this.chart) {
            this.chart.destroy();
            this.chart = void 0;
        }
        this.chart = this.getChartBuilder(this.ctx /*, data, this.options*/);
    }
}
BaseChartDirective.decorators = [
    { type: Directive, args: [{
                // tslint:disable-next-line:directive-selector
                selector: 'canvas[baseChart]',
                exportAs: 'base-chart'
            },] }
];
/** @nocollapse */
BaseChartDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: ThemeService }
];
BaseChartDirective.propDecorators = {
    data: [{ type: Input }],
    datasets: [{ type: Input }],
    labels: [{ type: Input }],
    options: [{ type: Input }],
    chartType: [{ type: Input }],
    colors: [{ type: Input }],
    legend: [{ type: Input }],
    plugins: [{ type: Input }],
    chartClick: [{ type: Output }],
    chartHover: [{ type: Output }]
};
if (false) {
    /** @type {?} */
    BaseChartDirective.prototype.data;
    /** @type {?} */
    BaseChartDirective.prototype.datasets;
    /** @type {?} */
    BaseChartDirective.prototype.labels;
    /** @type {?} */
    BaseChartDirective.prototype.options;
    /** @type {?} */
    BaseChartDirective.prototype.chartType;
    /** @type {?} */
    BaseChartDirective.prototype.colors;
    /** @type {?} */
    BaseChartDirective.prototype.legend;
    /** @type {?} */
    BaseChartDirective.prototype.plugins;
    /** @type {?} */
    BaseChartDirective.prototype.chartClick;
    /** @type {?} */
    BaseChartDirective.prototype.chartHover;
    /** @type {?} */
    BaseChartDirective.prototype.ctx;
    /** @type {?} */
    BaseChartDirective.prototype.chart;
    /**
     * @type {?}
     * @private
     */
    BaseChartDirective.prototype.initFlag;
    /**
     * @type {?}
     * @private
     */
    BaseChartDirective.prototype.subs;
    /**
     * @type {?}
     * @private
     */
    BaseChartDirective.prototype.element;
    /**
     * @type {?}
     * @private
     */
    BaseChartDirective.prototype.themeService;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZS1jaGFydC5kaXJlY3RpdmUuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9uZzItY2hhcnRzLyIsInNvdXJjZXMiOlsibGliL2Jhc2UtY2hhcnQuZGlyZWN0aXZlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7QUFBQSxPQUFPLEVBQ0wsU0FBUyxFQUlULEtBQUssRUFDTCxNQUFNLEVBQ04sWUFBWSxFQUNaLFVBQVUsR0FFWCxNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLEtBQUssT0FBTyxNQUFNLFVBQVUsQ0FBQztBQUNwQyxPQUFPLEVBQUUsU0FBUyxFQUFFLE1BQU0sY0FBYyxDQUFDO0FBRXpDLE9BQU8sRUFBRSxZQUFZLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUUvQyxPQUFPLEtBQUssQ0FBQyxNQUFNLFFBQVEsQ0FBQzs7OztBQVU1QixxREFFQzs7O0lBREMsNkNBQVk7Ozs7O0FBR2Qsc0RBaURDOzs7Ozs7O0lBaERDLDhGQUF1RDs7Ozs7O0lBQ3ZELDZGQUFzRDs7Ozs7O0lBRXRELGdHQUF5RDs7Ozs7O0lBQ3pELCtGQUF3RDs7Ozs7O0lBRXhELGdHQUF5RDs7Ozs7O0lBQ3pELCtGQUF3RDs7Ozs7O0lBRXhELHdHQUFpRTs7Ozs7O0lBQ2pFLHVHQUFnRTs7Ozs7O0lBRWhFLHVHQUFnRTs7Ozs7O0lBQ2hFLHNHQUErRDs7Ozs7O0lBSy9ELGdHQUF5RDs7Ozs7O0lBQ3pELCtGQUF3RDs7Ozs7OztJQUd4RCxzR0FBdUU7Ozs7Ozs7SUFDdkUscUdBQXNFOzs7Ozs7O0lBR3RFLDhHQUErRTs7Ozs7OztJQUMvRSw2R0FBOEU7Ozs7Ozs7SUFFOUUsNkdBQThFOzs7Ozs7O0lBQzlFLDRHQUE2RTs7Ozs7OztJQUk3RSxrSEFBaUY7Ozs7Ozs7SUFHakYsaUhBQWdGOzs7Ozs7O0lBR2hGLHNHQUFzRTs7Ozs7OztJQUN0RSxxR0FBcUU7Ozs7Ozs7SUFFckUsd0dBQWtGOzs7OztJQUNsRixrRkFBcUM7Ozs7Ozs7SUFHckMsb0dBQTZEOztBQWEvRCxNQUFN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SUFDM0Msc0NBQWtEOztJQUNsRCxvQ0FBZ0M7O0lBQ2hDLHFDQUFtRDs7SUFDbkQsdUNBQTZDOztJQUM3QyxvQ0FBZ0M7O0lBQ2hDLG9DQUFnQzs7SUFDaEMscUNBQXFFOztJQUVyRSx3Q0FBc0c7O0lBQ3RHLHdDQUFvRzs7SUFFcEcsaUNBQW1COztJQUNuQixtQ0FBb0I7Ozs7O0lBQ3BCLHNDQUF5Qjs7Ozs7SUFFekIsa0NBQWtDOzs7OztJQWNoQyxxQ0FBMkI7Ozs7O0lBQzNCLDBDQUFrQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XHJcbiAgRGlyZWN0aXZlLFxyXG4gIE9uRGVzdHJveSxcclxuICBPbkNoYW5nZXMsXHJcbiAgT25Jbml0LFxyXG4gIElucHV0LFxyXG4gIE91dHB1dCxcclxuICBFdmVudEVtaXR0ZXIsXHJcbiAgRWxlbWVudFJlZixcclxuICBTaW1wbGVDaGFuZ2VzLFxyXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgKiBhcyBjaGFydEpzIGZyb20gJ2NoYXJ0LmpzJztcclxuaW1wb3J0IHsgZ2V0Q29sb3JzIH0gZnJvbSAnLi9nZXQtY29sb3JzJztcclxuaW1wb3J0IHsgQ29sb3IgfSBmcm9tICcuL2NvbG9yJztcclxuaW1wb3J0IHsgVGhlbWVTZXJ2aWNlIH0gZnJvbSAnLi90aGVtZS5zZXJ2aWNlJztcclxuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcyc7XHJcbmltcG9ydCAqIGFzIF8gZnJvbSAnbG9kYXNoJztcclxuXHJcbmV4cG9ydCB0eXBlIFNpbmdsZURhdGFTZXQgPSAobnVtYmVyW10gfCBjaGFydEpzLkNoYXJ0UG9pbnRbXSk7XHJcbmV4cG9ydCB0eXBlIE11bHRpRGF0YVNldCA9IChudW1iZXJbXSB8IGNoYXJ0SnMuQ2hhcnRQb2ludFtdKVtdO1xyXG5leHBvcnQgdHlwZSBTaW5nbGVPck11bHRpRGF0YVNldCA9IFNpbmdsZURhdGFTZXQgfCBNdWx0aURhdGFTZXQ7XHJcblxyXG4vKiBUaGUgZm9sbG93aW5nIHR3byB0eXBlcyBhcmUgY29waWVkIGZyb20gQHR5cGVzL2NoYXJ0LmpzIGJlY2F1c2UgdGhleSBhcmUgbm90XHJcbiAqIGV4cG9ydGVkIGZyb20gdGhlcmUuIFRoZXJlIGlzIGEgcHVsbCByZXF1ZXN0IHRvIGRlZmluaXRlbHkgdHlwZSByZXF1ZXN0aW5nIHRoaXNcclxuICogY2hhbmdlIChQUiAjMzM2MTQgaHR0cHM6Ly9naXRodWIuY29tL0RlZmluaXRlbHlUeXBlZC9EZWZpbml0ZWx5VHlwZWQvcHVsbC8zMzYxNClcclxuICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgUGx1Z2luU2VydmljZUdsb2JhbFJlZ2lzdHJhdGlvbiB7XHJcbiAgaWQ/OiBzdHJpbmc7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgUGx1Z2luU2VydmljZVJlZ2lzdHJhdGlvbk9wdGlvbnMge1xyXG4gIGJlZm9yZUluaXQ/KGNoYXJ0SW5zdGFuY2U6IENoYXJ0LCBvcHRpb25zPzogYW55KTogdm9pZDtcclxuICBhZnRlckluaXQ/KGNoYXJ0SW5zdGFuY2U6IENoYXJ0LCBvcHRpb25zPzogYW55KTogdm9pZDtcclxuXHJcbiAgYmVmb3JlVXBkYXRlPyhjaGFydEluc3RhbmNlOiBDaGFydCwgb3B0aW9ucz86IGFueSk6IHZvaWQ7XHJcbiAgYWZ0ZXJVcGRhdGU/KGNoYXJ0SW5zdGFuY2U6IENoYXJ0LCBvcHRpb25zPzogYW55KTogdm9pZDtcclxuXHJcbiAgYmVmb3JlTGF5b3V0PyhjaGFydEluc3RhbmNlOiBDaGFydCwgb3B0aW9ucz86IGFueSk6IHZvaWQ7XHJcbiAgYWZ0ZXJMYXlvdXQ/KGNoYXJ0SW5zdGFuY2U6IENoYXJ0LCBvcHRpb25zPzogYW55KTogdm9pZDtcclxuXHJcbiAgYmVmb3JlRGF0YXNldHNVcGRhdGU/KGNoYXJ0SW5zdGFuY2U6IENoYXJ0LCBvcHRpb25zPzogYW55KTogdm9pZDtcclxuICBhZnRlckRhdGFzZXRzVXBkYXRlPyhjaGFydEluc3RhbmNlOiBDaGFydCwgb3B0aW9ucz86IGFueSk6IHZvaWQ7XHJcblxyXG4gIGJlZm9yZURhdGFzZXRVcGRhdGU/KGNoYXJ0SW5zdGFuY2U6IENoYXJ0LCBvcHRpb25zPzogYW55KTogdm9pZDtcclxuICBhZnRlckRhdGFzZXRVcGRhdGU/KGNoYXJ0SW5zdGFuY2U6IENoYXJ0LCBvcHRpb25zPzogYW55KTogdm9pZDtcclxuXHJcbiAgLy8gVGhpcyBpcyBjYWxsZWQgYXQgdGhlIHN0YXJ0IG9mIGEgcmVuZGVyLiBJdCBpcyBvbmx5IGNhbGxlZCBvbmNlLCBldmVuIGlmXHJcbiAgLy8gdGhlIGFuaW1hdGlvbiB3aWxsIHJ1biBmb3IgYSBudW1iZXIgb2YgZnJhbWVzLiBVc2UgYmVmb3JlRHJhdyBvciBhZnRlckRyYXdcclxuICAvLyB0byBkbyBzb21ldGhpbmcgb24gZWFjaCBhbmltYXRpb24gZnJhbWVcclxuICBiZWZvcmVSZW5kZXI/KGNoYXJ0SW5zdGFuY2U6IENoYXJ0LCBvcHRpb25zPzogYW55KTogdm9pZDtcclxuICBhZnRlclJlbmRlcj8oY2hhcnRJbnN0YW5jZTogQ2hhcnQsIG9wdGlvbnM/OiBhbnkpOiB2b2lkO1xyXG5cclxuICAvLyBFYXNpbmcgaXMgZm9yIGFuaW1hdGlvblxyXG4gIGJlZm9yZURyYXc/KGNoYXJ0SW5zdGFuY2U6IENoYXJ0LCBlYXNpbmc6IHN0cmluZywgb3B0aW9ucz86IGFueSk6IHZvaWQ7XHJcbiAgYWZ0ZXJEcmF3PyhjaGFydEluc3RhbmNlOiBDaGFydCwgZWFzaW5nOiBzdHJpbmcsIG9wdGlvbnM/OiBhbnkpOiB2b2lkO1xyXG5cclxuICAvLyBCZWZvcmUgdGhlIGRhdGFzZXRzIGFyZSBkcmF3biBidXQgYWZ0ZXIgc2NhbGVzIGFyZSBkcmF3blxyXG4gIGJlZm9yZURhdGFzZXRzRHJhdz8oY2hhcnRJbnN0YW5jZTogQ2hhcnQsIGVhc2luZzogc3RyaW5nLCBvcHRpb25zPzogYW55KTogdm9pZDtcclxuICBhZnRlckRhdGFzZXRzRHJhdz8oY2hhcnRJbnN0YW5jZTogQ2hhcnQsIGVhc2luZzogc3RyaW5nLCBvcHRpb25zPzogYW55KTogdm9pZDtcclxuXHJcbiAgYmVmb3JlRGF0YXNldERyYXc/KGNoYXJ0SW5zdGFuY2U6IENoYXJ0LCBlYXNpbmc6IHN0cmluZywgb3B0aW9ucz86IGFueSk6IHZvaWQ7XHJcbiAgYWZ0ZXJEYXRhc2V0RHJhdz8oY2hhcnRJbnN0YW5jZTogQ2hhcnQsIGVhc2luZzogc3RyaW5nLCBvcHRpb25zPzogYW55KTogdm9pZDtcclxuXHJcbiAgLy8gQ2FsbGVkIGJlZm9yZSBkcmF3aW5nIHRoZSBgdG9vbHRpcGAuIElmIGFueSBwbHVnaW4gcmV0dXJucyBgZmFsc2VgLFxyXG4gIC8vIHRoZSB0b29sdGlwIGRyYXdpbmcgaXMgY2FuY2VsbGVkIHVudGlsIGFub3RoZXIgYHJlbmRlcmAgaXMgdHJpZ2dlcmVkLlxyXG4gIGJlZm9yZVRvb2x0aXBEcmF3PyhjaGFydEluc3RhbmNlOiBDaGFydCwgdG9vbHRpcERhdGE/OiBhbnksIG9wdGlvbnM/OiBhbnkpOiB2b2lkO1xyXG4gIC8vIENhbGxlZCBhZnRlciBkcmF3aW5nIHRoZSBgdG9vbHRpcGAuIE5vdGUgdGhhdCB0aGlzIGhvb2sgd2lsbCBub3QsXHJcbiAgLy8gYmUgY2FsbGVkIGlmIHRoZSB0b29sdGlwIGRyYXdpbmcgaGFzIGJlZW4gcHJldmlvdXNseSBjYW5jZWxsZWQuXHJcbiAgYWZ0ZXJUb29sdGlwRHJhdz8oY2hhcnRJbnN0YW5jZTogQ2hhcnQsIHRvb2x0aXBEYXRhPzogYW55LCBvcHRpb25zPzogYW55KTogdm9pZDtcclxuXHJcbiAgLy8gQ2FsbGVkIHdoZW4gYW4gZXZlbnQgb2NjdXJzIG9uIHRoZSBjaGFydFxyXG4gIGJlZm9yZUV2ZW50PyhjaGFydEluc3RhbmNlOiBDaGFydCwgZXZlbnQ6IEV2ZW50LCBvcHRpb25zPzogYW55KTogdm9pZDtcclxuICBhZnRlckV2ZW50PyhjaGFydEluc3RhbmNlOiBDaGFydCwgZXZlbnQ6IEV2ZW50LCBvcHRpb25zPzogYW55KTogdm9pZDtcclxuXHJcbiAgcmVzaXplPyhjaGFydEluc3RhbmNlOiBDaGFydCwgbmV3Q2hhcnRTaXplOiBDaGFydC5DaGFydFNpemUsIG9wdGlvbnM/OiBhbnkpOiB2b2lkO1xyXG4gIGRlc3Ryb3k/KGNoYXJ0SW5zdGFuY2U6IENoYXJ0KTogdm9pZDtcclxuXHJcbiAgLyoqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi41LjAuIFVzZSBgYWZ0ZXJMYXlvdXRgIGluc3RlYWQuICovXHJcbiAgYWZ0ZXJTY2FsZVVwZGF0ZT8oY2hhcnRJbnN0YW5jZTogQ2hhcnQsIG9wdGlvbnM/OiBhbnkpOiB2b2lkO1xyXG59XHJcblxyXG5leHBvcnQgdHlwZSBQbHVnaW5TZXJ2aWNlR2xvYmFsUmVnaXN0cmF0aW9uQW5kT3B0aW9ucyA9IFBsdWdpblNlcnZpY2VHbG9iYWxSZWdpc3RyYXRpb24gJiBQbHVnaW5TZXJ2aWNlUmVnaXN0cmF0aW9uT3B0aW9ucztcclxuZXhwb3J0IHR5cGUgU2luZ2xlTGluZUxhYmVsID0gc3RyaW5nO1xyXG5leHBvcnQgdHlwZSBNdWx0aUxpbmVMYWJlbCA9IHN0cmluZ1tdO1xyXG5leHBvcnQgdHlwZSBMYWJlbCA9IFNpbmdsZUxpbmVMYWJlbCB8IE11bHRpTGluZUxhYmVsO1xyXG5cclxuQERpcmVjdGl2ZSh7XHJcbiAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOmRpcmVjdGl2ZS1zZWxlY3RvclxyXG4gIHNlbGVjdG9yOiAnY2FudmFzW2Jhc2VDaGFydF0nLFxyXG4gIGV4cG9ydEFzOiAnYmFzZS1jaGFydCdcclxufSlcclxuZXhwb3J0IGNsYXNzIEJhc2VDaGFydERpcmVjdGl2ZSBpbXBsZW1lbnRzIE9uRGVzdHJveSwgT25DaGFuZ2VzLCBPbkluaXQsIE9uRGVzdHJveSB7XHJcbiAgQElucHV0KCkgcHVibGljIGRhdGE6IFNpbmdsZU9yTXVsdGlEYXRhU2V0O1xyXG4gIEBJbnB1dCgpIHB1YmxpYyBkYXRhc2V0czogY2hhcnRKcy5DaGFydERhdGFTZXRzW107XHJcbiAgQElucHV0KCkgcHVibGljIGxhYmVsczogTGFiZWxbXTtcclxuICBASW5wdXQoKSBwdWJsaWMgb3B0aW9uczogY2hhcnRKcy5DaGFydE9wdGlvbnMgPSB7fTtcclxuICBASW5wdXQoKSBwdWJsaWMgY2hhcnRUeXBlOiBjaGFydEpzLkNoYXJ0VHlwZTtcclxuICBASW5wdXQoKSBwdWJsaWMgY29sb3JzOiBDb2xvcltdO1xyXG4gIEBJbnB1dCgpIHB1YmxpYyBsZWdlbmQ6IGJvb2xlYW47XHJcbiAgQElucHV0KCkgcHVibGljIHBsdWdpbnM6IFBsdWdpblNlcnZpY2VHbG9iYWxSZWdpc3RyYXRpb25BbmRPcHRpb25zW107XHJcblxyXG4gIEBPdXRwdXQoKSBwdWJsaWMgY2hhcnRDbGljazogRXZlbnRFbWl0dGVyPHsgZXZlbnQ/OiBNb3VzZUV2ZW50LCBhY3RpdmU/OiB7fVtdIH0+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4gIEBPdXRwdXQoKSBwdWJsaWMgY2hhcnRIb3ZlcjogRXZlbnRFbWl0dGVyPHsgZXZlbnQ6IE1vdXNlRXZlbnQsIGFjdGl2ZToge31bXSB9PiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuXHJcbiAgcHVibGljIGN0eDogc3RyaW5nO1xyXG4gIHB1YmxpYyBjaGFydDogQ2hhcnQ7XHJcbiAgcHJpdmF0ZSBpbml0RmxhZyA9IGZhbHNlO1xyXG5cclxuICBwcml2YXRlIHN1YnM6IFN1YnNjcmlwdGlvbltdID0gW107XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlZ2lzdGVyIGEgcGx1Z2luLlxyXG4gICAqL1xyXG4gIHB1YmxpYyBzdGF0aWMgcmVnaXN0ZXJQbHVnaW4ocGx1Z2luOiBQbHVnaW5TZXJ2aWNlR2xvYmFsUmVnaXN0cmF0aW9uQW5kT3B0aW9ucykge1xyXG4gICAgY2hhcnRKcy5DaGFydC5wbHVnaW5zLnJlZ2lzdGVyKHBsdWdpbik7XHJcbiAgfVxyXG5cclxuICBwdWJsaWMgc3RhdGljIHVucmVnaXN0ZXJQbHVnaW4ocGx1Z2luOiBQbHVnaW5TZXJ2aWNlR2xvYmFsUmVnaXN0cmF0aW9uQW5kT3B0aW9ucykge1xyXG4gICAgY2hhcnRKcy5DaGFydC5wbHVnaW5zLnVucmVnaXN0ZXIocGx1Z2luKTtcclxuICB9XHJcblxyXG4gIHB1YmxpYyBjb25zdHJ1Y3RvcihcclxuICAgIHByaXZhdGUgZWxlbWVudDogRWxlbWVudFJlZixcclxuICAgIHByaXZhdGUgdGhlbWVTZXJ2aWNlOiBUaGVtZVNlcnZpY2UsXHJcbiAgKSB7IH1cclxuXHJcbiAgcHVibGljIG5nT25Jbml0KCkge1xyXG4gICAgdGhpcy5jdHggPSB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudC5nZXRDb250ZXh0KCcyZCcpO1xyXG4gICAgdGhpcy5pbml0RmxhZyA9IHRydWU7XHJcbiAgICBpZiAodGhpcy5kYXRhIHx8IHRoaXMuZGF0YXNldHMpIHtcclxuICAgICAgdGhpcy5yZWZyZXNoKCk7XHJcbiAgICB9XHJcbiAgICB0aGlzLnN1YnMucHVzaCh0aGlzLnRoZW1lU2VydmljZS5jb2xvcnNjaGVtZXNPcHRpb25zLnN1YnNjcmliZShyID0+IHRoaXMudGhlbWVDaGFuZ2VkKHIpKSk7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIHRoZW1lQ2hhbmdlZChvcHRpb25zOiB7fSkge1xyXG4gICAgdGhpcy5yZWZyZXNoKCk7XHJcbiAgfVxyXG5cclxuICBwdWJsaWMgbmdPbkNoYW5nZXMoY2hhbmdlczogU2ltcGxlQ2hhbmdlcykge1xyXG4gICAgaWYgKHRoaXMuaW5pdEZsYWcpIHtcclxuICAgICAgbGV0IHVwZGF0ZVJlcXVpcmVkID0gZmFsc2U7XHJcbiAgICAgIC8vIENoZWNrIGlmIHRoZSBjaGFuZ2VzIGFyZSBpbiB0aGUgZGF0YSBvciBkYXRhc2V0cyBvciBsYWJlbHMgb3IgbGVnZW5kXHJcblxyXG4gICAgICBpZiAoY2hhbmdlcy5oYXNPd25Qcm9wZXJ0eSgnZGF0YScpIHx8IGNoYW5nZXMuaGFzT3duUHJvcGVydHkoJ2RhdGFzZXRzJykpIHtcclxuICAgICAgICBpZiAoY2hhbmdlcy5kYXRhKSB7XHJcbiAgICAgICAgICB0aGlzLnVwZGF0ZUNoYXJ0RGF0YShjaGFuZ2VzLmRhdGEuY3VycmVudFZhbHVlKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgdGhpcy51cGRhdGVDaGFydERhdGEoY2hhbmdlcy5kYXRhc2V0cy5jdXJyZW50VmFsdWUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdXBkYXRlUmVxdWlyZWQgPSB0cnVlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoY2hhbmdlcy5oYXNPd25Qcm9wZXJ0eSgnbGFiZWxzJykpIHtcclxuICAgICAgICB0aGlzLmNoYXJ0LmRhdGEubGFiZWxzID0gY2hhbmdlcy5sYWJlbHMuY3VycmVudFZhbHVlO1xyXG5cclxuICAgICAgICB1cGRhdGVSZXF1aXJlZCA9IHRydWU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChjaGFuZ2VzLmhhc093blByb3BlcnR5KCdsZWdlbmQnKSkge1xyXG4gICAgICAgIHRoaXMuY2hhcnQuY29uZmlnLm9wdGlvbnMubGVnZW5kLmRpc3BsYXkgPSBjaGFuZ2VzLmxlZ2VuZC5jdXJyZW50VmFsdWU7XHJcbiAgICAgICAgdGhpcy5jaGFydC5nZW5lcmF0ZUxlZ2VuZCgpO1xyXG5cclxuICAgICAgICB1cGRhdGVSZXF1aXJlZCA9IHRydWU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICh1cGRhdGVSZXF1aXJlZCkge1xyXG4gICAgICAgIC8vIC4uLiBpZiBzbywgdXBkYXRlIGNoYXJ0XHJcbiAgICAgICAgdGhpcy5jaGFydC51cGRhdGUoKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAvLyBvdGhlcndpc2UgcmVidWlsZCB0aGUgY2hhcnRcclxuICAgICAgICB0aGlzLnJlZnJlc2goKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcHVibGljIG5nT25EZXN0cm95KCkge1xyXG4gICAgaWYgKHRoaXMuY2hhcnQpIHtcclxuICAgICAgdGhpcy5jaGFydC5kZXN0cm95KCk7XHJcbiAgICAgIHRoaXMuY2hhcnQgPSB2b2lkIDA7XHJcbiAgICB9XHJcbiAgICB0aGlzLnN1YnMuZm9yRWFjaCh4ID0+IHgudW5zdWJzY3JpYmUoKSk7XHJcbiAgfVxyXG5cclxuICBwdWJsaWMgdXBkYXRlKGR1cmF0aW9uPzogYW55LCBsYXp5PzogYW55KSB7XHJcbiAgICByZXR1cm4gdGhpcy5jaGFydC51cGRhdGUoZHVyYXRpb24sIGxhenkpO1xyXG4gIH1cclxuXHJcbiAgcHVibGljIGhpZGVEYXRhc2V0KGluZGV4OiBudW1iZXIsIGhpZGRlbjogYm9vbGVhbikge1xyXG4gICAgdGhpcy5jaGFydC5nZXREYXRhc2V0TWV0YShpbmRleCkuaGlkZGVuID0gaGlkZGVuO1xyXG4gICAgdGhpcy5jaGFydC51cGRhdGUoKTtcclxuICB9XHJcblxyXG4gIHB1YmxpYyBpc0RhdGFzZXRIaWRkZW4oaW5kZXg6IG51bWJlcik6IGJvb2xlYW4ge1xyXG4gICAgcmV0dXJuIHRoaXMuY2hhcnQuZ2V0RGF0YXNldE1ldGEoaW5kZXgpLmhpZGRlbjtcclxuICB9XHJcblxyXG4gIHB1YmxpYyB0b0Jhc2U2NEltYWdlKCk6IHN0cmluZyB7XHJcbiAgICByZXR1cm4gdGhpcy5jaGFydC50b0Jhc2U2NEltYWdlKCk7XHJcbiAgfVxyXG5cclxuICBwdWJsaWMgZ2V0Q2hhcnRCdWlsZGVyKGN0eDogc3RyaW5nLyosIGRhdGE6YW55W10sIG9wdGlvbnM6YW55Ki8pOiBDaGFydCB7XHJcbiAgICBjb25zdCBkYXRhc2V0cyA9IHRoaXMuZ2V0RGF0YXNldHMoKTtcclxuXHJcbiAgICBjb25zdCBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5vcHRpb25zKTtcclxuICAgIGlmICh0aGlzLmxlZ2VuZCA9PT0gZmFsc2UpIHtcclxuICAgICAgb3B0aW9ucy5sZWdlbmQgPSB7IGRpc3BsYXk6IGZhbHNlIH07XHJcbiAgICB9XHJcbiAgICAvLyBob29rIGZvciBvbkhvdmVyIGFuZCBvbkNsaWNrIGV2ZW50c1xyXG4gICAgb3B0aW9ucy5ob3ZlciA9IG9wdGlvbnMuaG92ZXIgfHwge307XHJcbiAgICBpZiAoIW9wdGlvbnMuaG92ZXIub25Ib3Zlcikge1xyXG4gICAgICBvcHRpb25zLmhvdmVyLm9uSG92ZXIgPSAoZXZlbnQ6IE1vdXNlRXZlbnQsIGFjdGl2ZToge31bXSkgPT4ge1xyXG4gICAgICAgIGlmIChhY3RpdmUgJiYgIWFjdGl2ZS5sZW5ndGgpIHtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jaGFydEhvdmVyLmVtaXQoeyBldmVudCwgYWN0aXZlIH0pO1xyXG4gICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghb3B0aW9ucy5vbkNsaWNrKSB7XHJcbiAgICAgIG9wdGlvbnMub25DbGljayA9IChldmVudD86IE1vdXNlRXZlbnQsIGFjdGl2ZT86IHt9W10pID0+IHtcclxuICAgICAgICB0aGlzLmNoYXJ0Q2xpY2suZW1pdCh7IGV2ZW50LCBhY3RpdmUgfSk7XHJcbiAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgbWVyZ2VkT3B0aW9ucyA9IHRoaXMuc21hcnRNZXJnZShvcHRpb25zLCB0aGlzLnRoZW1lU2VydmljZS5nZXRDb2xvcnNjaGVtZXNPcHRpb25zKCkpO1xyXG5cclxuICAgIGNvbnN0IGNoYXJ0Q29uZmlnOiBjaGFydEpzLkNoYXJ0Q29uZmlndXJhdGlvbiA9IHtcclxuICAgICAgdHlwZTogdGhpcy5jaGFydFR5cGUsXHJcbiAgICAgIGRhdGE6IHtcclxuICAgICAgICBsYWJlbHM6IHRoaXMubGFiZWxzLFxyXG4gICAgICAgIGRhdGFzZXRzXHJcbiAgICAgIH0sXHJcbiAgICAgIHBsdWdpbnM6IHRoaXMucGx1Z2lucyxcclxuICAgICAgb3B0aW9uczogbWVyZ2VkT3B0aW9ucyxcclxuICAgIH07XHJcblxyXG4gICAgcmV0dXJuIG5ldyBjaGFydEpzLkNoYXJ0KGN0eCwgY2hhcnRDb25maWcpO1xyXG4gIH1cclxuXHJcbiAgc21hcnRNZXJnZShvcHRpb25zOiBhbnksIG92ZXJyaWRlczogYW55LCBsZXZlbDogbnVtYmVyID0gMCk6IGFueSB7XHJcbiAgICBpZiAobGV2ZWwgPT09IDApIHtcclxuICAgICAgb3B0aW9ucyA9IF8uY2xvbmVEZWVwKG9wdGlvbnMpO1xyXG4gICAgfVxyXG4gICAgY29uc3Qga2V5c1RvVXBkYXRlID0gT2JqZWN0LmtleXMob3ZlcnJpZGVzKTtcclxuICAgIGtleXNUb1VwZGF0ZS5mb3JFYWNoKGtleSA9PiB7XHJcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KG92ZXJyaWRlc1trZXldKSkge1xyXG4gICAgICAgIGNvbnN0IGFycmF5RWxlbWVudHMgPSBvcHRpb25zW2tleV07XHJcbiAgICAgICAgaWYgKGFycmF5RWxlbWVudHMpIHtcclxuICAgICAgICAgIGFycmF5RWxlbWVudHMuZm9yRWFjaChyID0+IHtcclxuICAgICAgICAgICAgdGhpcy5zbWFydE1lcmdlKHIsIG92ZXJyaWRlc1trZXldWzBdLCBsZXZlbCArIDEpO1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiAob3ZlcnJpZGVzW2tleV0pID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgIGlmICghKGtleSBpbiBvcHRpb25zKSkge1xyXG4gICAgICAgICAgb3B0aW9uc1trZXldID0ge307XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuc21hcnRNZXJnZShvcHRpb25zW2tleV0sIG92ZXJyaWRlc1trZXldLCBsZXZlbCArIDEpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIG9wdGlvbnNba2V5XSA9IG92ZXJyaWRlc1trZXldO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICAgIGlmIChsZXZlbCA9PT0gMCkge1xyXG4gICAgICByZXR1cm4gb3B0aW9ucztcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHByaXZhdGUgaXNDaGFydERhdGFTZXRzQXJyYXkodjogU2luZ2xlT3JNdWx0aURhdGFTZXQgfCBjaGFydEpzLkNoYXJ0RGF0YVNldHNbXSk6IHYgaXMgY2hhcnRKcy5DaGFydERhdGFTZXRzW10ge1xyXG4gICAgY29uc3QgZWxtID0gdlswXTtcclxuICAgIHJldHVybiAodHlwZW9mIChlbG0pID09PSAnb2JqZWN0JykgJiYgJ2RhdGEnIGluIGVsbTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgaXNNdWx0aUxpbmVMYWJlbChsYWJlbDogTGFiZWwpOiBsYWJlbCBpcyBNdWx0aUxpbmVMYWJlbCB7XHJcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheShsYWJlbCk7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGpvaW5MYWJlbChsYWJlbDogTGFiZWwpOiBzdHJpbmcge1xyXG4gICAgaWYgKCFsYWJlbCkge1xyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIGlmICh0aGlzLmlzTXVsdGlMaW5lTGFiZWwobGFiZWwpKSB7XHJcbiAgICAgIHJldHVybiBsYWJlbC5qb2luKCcgJyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXR1cm4gbGFiZWw7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIHVwZGF0ZUNoYXJ0RGF0YShuZXdEYXRhVmFsdWVzOiBTaW5nbGVPck11bHRpRGF0YVNldCB8IGNoYXJ0SnMuQ2hhcnREYXRhU2V0c1tdKTogdm9pZCB7XHJcbiAgICBpZiAodGhpcy5pc0NoYXJ0RGF0YVNldHNBcnJheShuZXdEYXRhVmFsdWVzKSkge1xyXG4gICAgICBpZiAobmV3RGF0YVZhbHVlcy5sZW5ndGggPT09IHRoaXMuY2hhcnQuZGF0YS5kYXRhc2V0cy5sZW5ndGgpIHtcclxuICAgICAgICB0aGlzLmNoYXJ0LmRhdGEuZGF0YXNldHMuZm9yRWFjaCgoZGF0YXNldCwgaTogbnVtYmVyKSA9PiB7XHJcbiAgICAgICAgICBkYXRhc2V0LmRhdGEgPSBuZXdEYXRhVmFsdWVzW2ldLmRhdGE7XHJcbiAgICAgICAgICBpZiAobmV3RGF0YVZhbHVlc1tpXS5sYWJlbCkge1xyXG4gICAgICAgICAgICBkYXRhc2V0LmxhYmVsID0gbmV3RGF0YVZhbHVlc1tpXS5sYWJlbDtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLmNoYXJ0LmRhdGEuZGF0YXNldHMgPSBbLi4ubmV3RGF0YVZhbHVlc107XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAoIXRoaXMuaXNTaW5nbGVEYXRhU2V0KG5ld0RhdGFWYWx1ZXMpKSB7XHJcbiAgICAgIGlmIChuZXdEYXRhVmFsdWVzLmxlbmd0aCA9PT0gdGhpcy5jaGFydC5kYXRhLmRhdGFzZXRzLmxlbmd0aCkge1xyXG4gICAgICAgIHRoaXMuY2hhcnQuZGF0YS5kYXRhc2V0cy5mb3JFYWNoKChkYXRhc2V0LCBpOiBudW1iZXIpID0+IHtcclxuICAgICAgICAgIGRhdGFzZXQuZGF0YSA9IG5ld0RhdGFWYWx1ZXNbaV07XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy5jaGFydC5kYXRhLmRhdGFzZXRzID0gbmV3RGF0YVZhbHVlcy5tYXAoKGRhdGE6IG51bWJlcltdLCBpbmRleDogbnVtYmVyKSA9PiB7XHJcbiAgICAgICAgICByZXR1cm4geyBkYXRhLCBsYWJlbDogdGhpcy5qb2luTGFiZWwodGhpcy5sYWJlbHNbaW5kZXhdKSB8fCBgTGFiZWwgJHtpbmRleH1gIH07XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMuY2hhcnQuZGF0YS5kYXRhc2V0c1swXS5kYXRhID0gbmV3RGF0YVZhbHVlcztcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHByaXZhdGUgaXNTaW5nbGVEYXRhU2V0KGRhdGE6IFNpbmdsZU9yTXVsdGlEYXRhU2V0KTogZGF0YSBpcyBTaW5nbGVEYXRhU2V0IHtcclxuICAgIHJldHVybiAhQXJyYXkuaXNBcnJheShkYXRhWzBdKTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgZ2V0RGF0YXNldHMoKSB7XHJcbiAgICBsZXQgZGF0YXNldHM6IGNoYXJ0SnMuQ2hhcnREYXRhU2V0c1tdID0gdm9pZCAwO1xyXG4gICAgLy8gaW4gY2FzZSBpZiBkYXRhc2V0cyBpcyBub3QgcHJvdmlkZWQsIGJ1dCBkYXRhIGlzIHByZXNlbnRcclxuICAgIGlmICghdGhpcy5kYXRhc2V0cyB8fCAhdGhpcy5kYXRhc2V0cy5sZW5ndGggJiYgKHRoaXMuZGF0YSAmJiB0aGlzLmRhdGEubGVuZ3RoKSkge1xyXG4gICAgICBpZiAoIXRoaXMuaXNTaW5nbGVEYXRhU2V0KHRoaXMuZGF0YSkpIHtcclxuICAgICAgICBkYXRhc2V0cyA9IHRoaXMuZGF0YS5tYXAoKGRhdGE6IG51bWJlcltdLCBpbmRleDogbnVtYmVyKSA9PiB7XHJcbiAgICAgICAgICByZXR1cm4geyBkYXRhLCBsYWJlbDogdGhpcy5qb2luTGFiZWwodGhpcy5sYWJlbHNbaW5kZXhdKSB8fCBgTGFiZWwgJHtpbmRleH1gIH07XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZGF0YXNldHMgPSBbeyBkYXRhOiB0aGlzLmRhdGEsIGxhYmVsOiBgTGFiZWwgMGAgfV07XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5kYXRhc2V0cyAmJiB0aGlzLmRhdGFzZXRzLmxlbmd0aCB8fFxyXG4gICAgICAoZGF0YXNldHMgJiYgZGF0YXNldHMubGVuZ3RoKSkge1xyXG4gICAgICBkYXRhc2V0cyA9ICh0aGlzLmRhdGFzZXRzIHx8IGRhdGFzZXRzKVxyXG4gICAgICAgIC5tYXAoKGVsbTogY2hhcnRKcy5DaGFydERhdGFTZXRzLCBpbmRleDogbnVtYmVyKSA9PiB7XHJcbiAgICAgICAgICBjb25zdCBuZXdFbG06IGNoYXJ0SnMuQ2hhcnREYXRhU2V0cyA9IE9iamVjdC5hc3NpZ24oe30sIGVsbSk7XHJcbiAgICAgICAgICBpZiAodGhpcy5jb2xvcnMgJiYgdGhpcy5jb2xvcnMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24obmV3RWxtLCB0aGlzLmNvbG9yc1tpbmRleF0pO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihuZXdFbG0sIGdldENvbG9ycyh0aGlzLmNoYXJ0VHlwZSwgaW5kZXgsIG5ld0VsbS5kYXRhLmxlbmd0aCkpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgcmV0dXJuIG5ld0VsbTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIWRhdGFzZXRzKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihgbmctY2hhcnRzIGNvbmZpZ3VyYXRpb24gZXJyb3IsXHJcbiAgICAgIGRhdGEgb3IgZGF0YXNldHMgZmllbGQgYXJlIHJlcXVpcmVkIHRvIHJlbmRlciBjaGFyICR7dGhpcy5jaGFydFR5cGV9YCk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGRhdGFzZXRzO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSByZWZyZXNoKCkge1xyXG4gICAgLy8gaWYgKHRoaXMub3B0aW9ucyAmJiB0aGlzLm9wdGlvbnMucmVzcG9uc2l2ZSkge1xyXG4gICAgLy8gICBzZXRUaW1lb3V0KCgpID0+IHRoaXMucmVmcmVzaCgpLCA1MCk7XHJcbiAgICAvLyB9XHJcblxyXG4gICAgLy8gdG9kbzogcmVtb3ZlIHRoaXMgbGluZSwgaXQgaXMgcHJvZHVjaW5nIGZsaWNrZXJpbmdcclxuICAgIGlmICh0aGlzLmNoYXJ0KSB7XHJcbiAgICAgIHRoaXMuY2hhcnQuZGVzdHJveSgpO1xyXG4gICAgICB0aGlzLmNoYXJ0ID0gdm9pZCAwO1xyXG4gICAgfVxyXG4gICAgdGhpcy5jaGFydCA9IHRoaXMuZ2V0Q2hhcnRCdWlsZGVyKHRoaXMuY3R4LyosIGRhdGEsIHRoaXMub3B0aW9ucyovKTtcclxuICB9XHJcbn1cclxuIl19